const fs = require('fs-extra')
const path = require('path')
const chokidar = require('chokidar')
const axios = require('axios')
const ffprobe = require('ffprobe')
const ffprobeStatic = require('ffprobe-static')
const sanitize = require('sanitize-filename')
const { exec } = require('child_process')
const { MovieDb } = require('moviedb-promise')
require('dotenv').config()

const MEDIA_PATH = process.env.MEDIA_PATH || '/media'
const TMDB_API_KEY = process.env.TMDB_API_KEY
const WATCH_FOLDERS = (process.env.WATCH_FOLDERS || '/media/downloads').split(',')

// Extensions vid√©o support√©es
const VIDEO_EXTENSIONS = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm', '.m4v']
const SUBTITLE_EXTENSIONS = ['.srt', '.vtt', '.ass', '.ssa', '.sub']

// Configuration TMDB
const TMDB_BASE_URL = 'https://api.themoviedb.org/3'
const TMDB_IMAGE_BASE_URL = 'https://image.tmdb.org/t/p/w500'

console.log('üé¨ Netflux Media Organizer d√©marr√©')
console.log(`üìÅ Dossier m√©dia: ${MEDIA_PATH}`)
console.log(`üëÄ Surveillance des dossiers: ${WATCH_FOLDERS.join(', ')}`)
console.log(`üîë TMDB API: ${TMDB_API_KEY ? 'Configur√©e' : 'Non configur√©e'}`)

class MediaOrganizer {
  constructor() {
    this.processingQueue = new Set()
    this.init()
  }

  async init() {
    await this.setupDirectories()
    this.startWatching()
  }

  // Cr√©er les dossiers n√©cessaires
  async setupDirectories() {
    const dirs = [
      path.join(MEDIA_PATH, 'films'),
      path.join(MEDIA_PATH, 'series'),
      path.join(MEDIA_PATH, 'downloads'),
      path.join(MEDIA_PATH, 'incoming'),
      path.join(MEDIA_PATH, 'processing')
    ]

    for (const dir of dirs) {
      await fs.ensureDir(dir)
    }
    console.log('üìÇ Dossiers cr√©√©s/v√©rifi√©s')
  }

  // D√©marrer la surveillance des dossiers
  startWatching() {
    const watcher = chokidar.watch(WATCH_FOLDERS, {
      ignored: /(^|[\/\\])\../, // Ignorer les fichiers cach√©s
      persistent: true,
      ignoreInitial: false
    })

    watcher
      .on('add', filePath => this.handleNewFile(filePath))
      .on('ready', () => console.log('üëÅÔ∏è Surveillance active des nouveaux fichiers'))
      .on('error', error => console.error('‚ùå Erreur de surveillance:', error))
  }

  // G√©rer un nouveau fichier d√©tect√©
  async handleNewFile(filePath) {
    try {
      const ext = path.extname(filePath).toLowerCase()
      
      if (!VIDEO_EXTENSIONS.includes(ext)) {
        return // Ignorer les fichiers non-vid√©o
      }

      // √âviter le traitement en double
      if (this.processingQueue.has(filePath)) {
        return
      }

      console.log(`üé¨ Nouveau fichier d√©tect√©: ${path.basename(filePath)}`)
      this.processingQueue.add(filePath)

      // Attendre que le fichier soit compl√®tement t√©l√©charg√©
      await this.waitForStability(filePath)
      
      // Traiter le film
      await this.processMovie(filePath)

    } catch (error) {
      console.error(`‚ùå Erreur lors du traitement de ${filePath}:`, error)
    } finally {
      this.processingQueue.delete(filePath)
    }
  }

  // Attendre que le fichier soit stable (t√©l√©chargement termin√©)
  async waitForStability(filePath) {
    console.log('‚è≥ Attente stabilit√©...')
    // Attendre 30 secondes pour s'assurer que le t√©l√©chargement est fini
    await new Promise(resolve => setTimeout(resolve, 30000))
  }

  // Traiter un film
  async processMovie(filePath) {
    try {
      console.log(`üîç Traitement du film: ${path.basename(filePath)}`)

      // Extraire le nom du film du nom de fichier
      const movieInfo = this.extractMovieInfo(path.basename(filePath))
      console.log(`üìù Info extraite:`, movieInfo)

      // Rechercher des m√©tadonn√©es
      let metadata = null
      if (TMDB_API_KEY) {
        metadata = await this.getMovieMetadata(movieInfo.title)
      }

      // Cr√©er le nom de dossier final
      const finalFolderName = this.createFolderName(movieInfo, metadata)
      const finalMovieDir = path.join(MEDIA_PATH, 'films', finalFolderName)

      // Cr√©er le dossier du film
      await fs.ensureDir(finalMovieDir)

      // D√©placer le fichier vid√©o
      const finalVideoPath = path.join(finalMovieDir, this.createFileName(movieInfo, metadata, path.extname(filePath)))
      await fs.move(filePath, finalVideoPath)
      console.log(`üì¶ Fichier d√©plac√©: ${finalVideoPath}`)

      // Rechercher et d√©placer les sous-titres associ√©s
      await this.moveAssociatedFiles(path.dirname(filePath), finalMovieDir, path.basename(filePath, path.extname(filePath)))

      // T√©l√©charger les m√©tadonn√©es suppl√©mentaires
      if (metadata) {
        await this.downloadAssets(metadata, finalMovieDir)
      }

      // Cr√©er un fichier d'informations
      await this.createInfoFile(finalMovieDir, movieInfo, metadata)

      console.log(`‚úÖ Film organis√© avec succ√®s: ${finalFolderName}`)

    } catch (error) {
      console.error(`‚ùå Erreur lors du traitement du film:`, error)
    }
  }

  // Extraire les informations du nom de fichier
  extractMovieInfo(filename) {
    const name = path.parse(filename).name
    const yearMatch = name.match(/(\d{4})/)
    const year = yearMatch ? parseInt(yearMatch[1]) : null
    
    let title = name
      .replace(/\d{4}.*/, '')
      .replace(/[\.\-_]+/g, ' ')
      .trim()

    return { title, year, originalName: filename }
  }

  // Rechercher sur TMDB
  async getMovieMetadata(title) {
    if (!moviedb) {
      console.log('‚ö†Ô∏è Cl√© API TMDB non configur√©e')
      return null
    }
    
    try {
      console.log(`üîç Recherche TMDB: "${title}"`)
      const searchResult = await moviedb.searchMovie({ query: title })
      
      if (searchResult.results && searchResult.results.length > 0) {
        const movie = searchResult.results[0]
        console.log(`‚úÖ Film trouv√© sur TMDB: ${movie.title} (${movie.release_date?.split('-')[0]})`)
        
        return {
          title: movie.title,
          year: movie.release_date ? new Date(movie.release_date).getFullYear() : null,
          overview: movie.overview,
          poster_path: movie.poster_path,
          backdrop_path: movie.backdrop_path,
          genres: movie.genre_ids || [],
          rating: movie.vote_average
        }
      }
      
      console.log(`‚ö†Ô∏è Aucun r√©sultat TMDB pour: ${title}`)
      return null
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration des m√©tadonn√©es TMDB:', error.message)
      return null
    }
  }

  // Cr√©er le nom du dossier final
  createFolderName(movieInfo, metadata) {
    if (metadata) {
      const year = metadata.release_date ? metadata.release_date.split('-')[0] : movieInfo.year
      return sanitize(`${metadata.title} (${year})`)
    }

    const year = movieInfo.year ? ` (${movieInfo.year})` : ''
    return sanitize(`${movieInfo.title}${year}`)
  }

  // Cr√©er le nom du fichier final
  createFileName(movieInfo, metadata, extension) {
    if (metadata) {
      const year = metadata.release_date ? metadata.release_date.split('-')[0] : movieInfo.year
      return sanitize(`${metadata.title} (${year})${extension}`)
    }

    const year = movieInfo.year ? ` (${movieInfo.year})` : ''
    return sanitize(`${movieInfo.title}${year}${extension}`)
  }

  // D√©placer les fichiers associ√©s (sous-titres, etc.)
  async moveAssociatedFiles(sourceDir, destDir, baseName) {
    try {
      const files = await fs.readdir(sourceDir)
      
      for (const file of files) {
        const filePath = path.join(sourceDir, file)
        const ext = path.extname(file).toLowerCase()
        
        // V√©rifier si c'est un fichier associ√©
        if (file.startsWith(baseName) && SUBTITLE_EXTENSIONS.includes(ext)) {
          const destPath = path.join(destDir, file)
          await fs.move(filePath, destPath)
          console.log(`üìÑ Fichier associ√© d√©plac√©: ${file}`)
        }
      }
    } catch (error) {
      console.error('‚ùå Erreur lors du d√©placement des fichiers associ√©s:', error)
    }
  }

  // T√©l√©charger les assets du film (poster, backdrop)
  async downloadAssets(metadata, movieDir) {
    try {
      // T√©l√©charger le poster
      if (metadata.poster_path) {
        const posterUrl = `${TMDB_IMAGE_BASE_URL}${metadata.poster_path}`
        const posterPath = path.join(movieDir, 'poster.jpg')
        await this.downloadImage(posterUrl, posterPath)
        console.log('üñºÔ∏è Poster t√©l√©charg√©')
      }

      // T√©l√©charger le backdrop
      if (metadata.backdrop_path) {
        const backdropUrl = `${TMDB_IMAGE_BASE_URL}${metadata.backdrop_path}`
        const backdropPath = path.join(movieDir, 'fanart.jpg')
        await this.downloadImage(backdropUrl, backdropPath)
        console.log('üñºÔ∏è Fanart t√©l√©charg√©')
      }
    } catch (error) {
      console.error('‚ùå Erreur lors du t√©l√©chargement des assets:', error)
    }
  }

  // T√©l√©charger une image
  async downloadImage(url, filePath) {
    try {
      const response = await axios({
        method: 'GET',
        url: url,
        responseType: 'stream'
      })

      const writer = fs.createWriteStream(filePath)
      response.data.pipe(writer)

      return new Promise((resolve, reject) => {
        writer.on('finish', resolve)
        writer.on('error', reject)
      })
    } catch (error) {
      console.error(`‚ùå Erreur t√©l√©chargement image ${url}:`, error.message)
    }
  }

  // Cr√©er un fichier d'informations
  async createInfoFile(movieDir, movieInfo, metadata) {
    try {
      const infoData = {
        originalName: movieInfo.originalName,
        extractedTitle: movieInfo.title,
        extractedYear: movieInfo.year,
        processedDate: new Date().toISOString(),
        ...(metadata && {
          tmdb: {
            id: metadata.id,
            title: metadata.title,
            originalTitle: metadata.original_title,
            overview: metadata.overview,
            releaseDate: metadata.release_date,
            voteAverage: metadata.vote_average,
            genres: metadata.genre_ids
          }
        })
      }

      const infoPath = path.join(movieDir, 'movie.nfo')
      await fs.writeJson(infoPath, infoData, { spaces: 2 })
      console.log('üìã Fichier d\'informations cr√©√©')

    } catch (error) {
      console.error('‚ùå Erreur cr√©ation fichier info:', error)
    }
  }
}

// D√©marrer le service
const organizer = new MediaOrganizer()

// Gestion des signaux pour arr√™t propre
process.on('SIGINT', () => {
  console.log('\nüõë Arr√™t du service d\'organisation...')
  process.exit(0)
})

process.on('SIGTERM', () => {
  console.log('\nüõë Arr√™t du service d\'organisation...')
  process.exit(0)
}) 