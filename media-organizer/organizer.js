const fs = require('fs-extra')
const path = require('path')
const chokidar = require('chokidar')
const axios = require('axios')
const ffprobe = require('ffprobe')
const ffprobeStatic = require('ffprobe-static')
const sanitize = require('sanitize-filename')
const { exec } = require('child_process')
const { MovieDb } = require('moviedb-promise')
require('dotenv').config()

const DOWNLOADS_PATH = process.env.DOWNLOADS_PATH || '/downloads'
const MOVIES_PATH = process.env.MOVIES_PATH || '/movies'
const TMDB_API_KEY = process.env.TMDB_API_KEY

// Utiliser les chemins Docker corrects
const MEDIA_PATH = process.env.MEDIA_PATH || '/media'
const DOWNLOADS_FOLDER = path.join(MEDIA_PATH, 'downloads')
const MOVIES_FOLDER = path.join(MEDIA_PATH, 'films')
const WATCH_FOLDERS = process.env.WATCH_FOLDERS ? 
  process.env.WATCH_FOLDERS.split(',').map(f => f.trim()) : 
  [DOWNLOADS_FOLDER, path.join(MEDIA_PATH, 'incoming')]

// Extensions de fichiers vid√©o support√©es
const VIDEO_EXTENSIONS = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm', '.m4v']

// Extensions de fichiers associ√©s (sous-titres, images, etc.)
const SUBTITLE_EXTENSIONS = ['.srt', '.vtt', '.ass', '.ssa', '.sub']
const IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.bmp', '.gif']
const INFO_EXTENSIONS = ['.txt', '.nfo', '.info']

// Configuration TMDB
const TMDB_BASE_URL = 'https://api.themoviedb.org/3'
const TMDB_IMAGE_BASE_URL = 'https://image.tmdb.org/t/p/w500'

console.log('üé¨ Netflux Media Organizer d√©marr√©')
console.log(`üìÅ Variables d'environnement:`)
console.log(`   - DOWNLOADS_PATH: ${DOWNLOADS_PATH}`)
console.log(`   - MOVIES_PATH: ${MOVIES_PATH}`)
console.log(`   - MEDIA_PATH: ${MEDIA_PATH}`)
console.log(`   - DOWNLOADS_FOLDER: ${DOWNLOADS_FOLDER}`)
console.log(`   - MOVIES_FOLDER: ${MOVIES_FOLDER}`)
console.log(`   - WATCH_FOLDERS: ${WATCH_FOLDERS.join(', ')}`)
console.log(`üîë TMDB API: ${TMDB_API_KEY ? 'Configur√©e' : 'Non configur√©e'}`)

class MediaOrganizer {
  constructor() {
    this.processingQueue = new Set()
    this.pendingFiles = new Map()
    this.stabilityDelay = 10000 // 10 secondes pour s'assurer que le fichier est stable
    this.processedMovies = new Map() // Pour associer les fichiers aux films
    
    // Initialiser TMDB
    this.moviedb = null
    if (TMDB_API_KEY) {
      this.moviedb = new MovieDb(TMDB_API_KEY)
      console.log('‚úÖ API TMDB initialis√©e')
    } else {
      console.log('‚ö†Ô∏è Cl√© API TMDB non configur√©e - Les m√©tadonn√©es ne seront pas r√©cup√©r√©es')
    }

    this.init()
  }

  async init() {
    await this.setupDirectories()
    
    // V√©rification initiale des fichiers existants
    console.log('üîç V√©rification des fichiers existants au d√©marrage...')
    await this.processExistingFiles()
    
    this.startWatching()
  }

  // Cr√©er les dossiers n√©cessaires
  async setupDirectories() {
    const dirs = [
      MEDIA_PATH,
      DOWNLOADS_FOLDER,
      MOVIES_FOLDER,
      path.join(MEDIA_PATH, 'series'),
      path.join(MEDIA_PATH, 'incoming'),
      path.join(MEDIA_PATH, 'processing')
    ]

    for (const dir of dirs) {
      await fs.ensureDir(dir)
      console.log(`üìÇ Dossier cr√©√©/v√©rifi√©: ${dir}`)
    }
    console.log('üìÇ Tous les dossiers sont pr√™ts')
  }

  // Traiter les fichiers existants au d√©marrage
  async processExistingFiles() {
    try {
      console.log('üîç V√©rification des fichiers existants au d√©marrage...')
      
      for (const folder of WATCH_FOLDERS) {
        if (await fs.pathExists(folder)) {
          console.log(`üìÇ V√©rification du dossier: ${folder}`)
          await this.scanFolder(folder)
        } else {
          console.log(`‚ö†Ô∏è Dossier introuvable: ${folder}`)
        }
      }
      
      console.log('‚úÖ V√©rification initiale termin√©e')
    } catch (error) {
      console.error('‚ùå Erreur lors de la v√©rification initiale:', error.message)
    }
  }

  // Scanner un dossier pour les fichiers existants
  async scanFolder(folderPath) {
    try {
      const files = await fs.readdir(folderPath, { withFileTypes: true })
      
      for (const file of files) {
        const filePath = path.join(folderPath, file.name)
        
        if (file.isFile()) {
          const ext = path.extname(file.name).toLowerCase()
          if (VIDEO_EXTENSIONS.includes(ext)) {
            console.log(`üé¨ Fichier vid√©o existant trouv√©: ${file.name}`)
            // Traitement imm√©diat pour les fichiers existants (ils sont d√©j√† stables)
            await this.processMovie(filePath)
          }
        } else if (file.isDirectory()) {
          // R√©cursion dans les sous-dossiers
          await this.scanFolder(filePath)
        }
      }
    } catch (error) {
      console.error(`‚ùå Erreur lors du scan du dossier ${folderPath}:`, error.message)
    }
  }

  // D√©marrer la surveillance des dossiers
  startWatching() {
    console.log('üîç D√©marrage de la surveillance...')
    
    // V√©rifier que les dossiers existent
    const existingFolders = []
    for (const folder of WATCH_FOLDERS) {
      if (fs.existsSync(folder)) {
        existingFolders.push(folder)
        console.log(`üëÄ Surveillance activ√©e pour: ${folder}`)
      } else {
        console.log(`‚ö†Ô∏è Dossier inexistant ignor√©: ${folder}`)
      }
    }

    if (existingFolders.length === 0) {
      console.error('‚ùå Aucun dossier de t√©l√©chargement trouv√© √† surveiller!')
      console.error('üìç Dossiers recherch√©s:', WATCH_FOLDERS)
      return
    }

    const watcher = chokidar.watch(existingFolders, {
      ignored: [
        /(^|[\/\\])\../, // Ignorer les fichiers cach√©s
        /node_modules/,
        /\.git/,
        /\.tmp$/,
        /\.part$/,
        /\.crdownload$/ // Fichiers de t√©l√©chargement Chrome
      ],
      persistent: true,
      ignoreInitial: true, // Ignorer les fichiers existants car on les a d√©j√† trait√©s
      depth: 5, // Scanner jusqu'√† 5 niveaux de profondeur
      awaitWriteFinish: {
        stabilityThreshold: 5000, // Attendre 5 secondes que le fichier soit stable
        pollInterval: 1000 // V√©rifier chaque seconde
      }
    })

    watcher
      .on('add', filePath => {
        console.log(`üìÅ Nouveau fichier ajout√©: ${path.basename(filePath)}`)
        console.log(`üìç Chemin complet: ${filePath}`)
        this.handleNewFile(filePath)
      })
      .on('ready', () => {
        console.log('üëÅÔ∏è Surveillance active des nouveaux fichiers')
        console.log(`üìç Dossiers surveill√©s: ${existingFolders.join(', ')}`)
      })
      .on('error', error => console.error('‚ùå Erreur de surveillance:', error))
  }

  // G√©rer les nouveaux fichiers avec v√©rification de stabilit√©
  async handleNewFile(filePath) {
    const fileName = path.basename(filePath)
    const ext = path.extname(filePath).toLowerCase()
    
    console.log(`üìÅ Nouveau fichier d√©tect√©: ${fileName}`)

    // V√©rifier si le fichier existe encore (peut avoir √©t√© supprim√©)
    if (!fs.existsSync(filePath)) {
      console.log(`‚ö†Ô∏è Fichier supprim√© avant traitement: ${fileName}`)
      return
    }

    // V√©rifier le type de fichier
    if (VIDEO_EXTENSIONS.includes(ext)) {
      console.log(`üé¨ Fichier vid√©o d√©tect√©: ${fileName}`)
      // Traiter directement car chokidar attend d√©j√† la stabilit√©
      await this.processMovie(filePath)
    } else if (SUBTITLE_EXTENSIONS.includes(ext) || IMAGE_EXTENSIONS.includes(ext) || INFO_EXTENSIONS.includes(ext)) {
      console.log(`üìé Fichier associ√© d√©tect√©: ${fileName}`)
      await this.handleAssociatedFile(filePath)
    } else {
      console.log(`‚ö†Ô∏è Type de fichier non support√©: ${fileName}`)
    }
  }

  // Programmer le traitement d'un fichier vid√©o
  async scheduleVideoProcessing(filePath) {
    const fileName = path.basename(filePath)
    
    // Annuler le traitement pr√©c√©dent s'il existe
    if (this.pendingFiles.has(filePath)) {
      clearTimeout(this.pendingFiles.get(filePath))
    }

    // Programmer le traitement apr√®s le d√©lai de stabilit√©
    const timeoutId = setTimeout(async () => {
      try {
        console.log(`üîç V√©rification de la stabilit√©: ${fileName}`)
        
        // V√©rifier plusieurs fois si le fichier est stable
        let isStable = false
        let attempts = 0
        const maxAttempts = 5
        
        while (!isStable && attempts < maxAttempts) {
          isStable = await this.isFileStable(filePath)
          if (!isStable) {
            console.log(`‚è≥ Fichier encore en cours de t√©l√©chargement, tentative ${attempts + 1}/${maxAttempts}`)
            await new Promise(resolve => setTimeout(resolve, 5000)) // Attendre 5 secondes de plus
          }
          attempts++
        }
        
        if (isStable) {
          console.log(`‚úÖ Fichier stable, traitement en cours: ${fileName}`)
          await this.processMovie(filePath)
        } else {
          console.log(`‚ö†Ô∏è Fichier toujours instable apr√®s ${maxAttempts} tentatives: ${fileName}`)
        }
        
        this.pendingFiles.delete(filePath)
      } catch (error) {
        console.error('‚ùå Erreur lors du traitement du fichier:', error.message)
        this.pendingFiles.delete(filePath)
      }
    }, this.stabilityDelay)

    this.pendingFiles.set(filePath, timeoutId)
  }

  // G√©rer les fichiers associ√©s (sous-titres, images, etc.)
  async handleAssociatedFile(filePath) {
    const fileName = path.basename(filePath)
    const baseName = path.basename(filePath, path.extname(filePath))
    
    // Chercher un film correspondant dans les films trait√©s
    let targetMovieFolder = null
    
    for (const [moviePath, movieInfo] of this.processedMovies.entries()) {
      const movieBaseName = path.basename(moviePath, path.extname(moviePath))
      
      // V√©rifier si le nom de base correspond ou contient le nom du film
      if (baseName.includes(movieInfo.cleanTitle) || movieInfo.cleanTitle.includes(baseName)) {
        targetMovieFolder = movieInfo.targetFolder
        break
      }
    }
    
    if (targetMovieFolder) {
      try {
        const targetPath = path.join(targetMovieFolder, fileName)
        await fs.promises.copyFile(filePath, targetPath)
        await fs.promises.unlink(filePath)
        console.log(`üìé Fichier associ√© d√©plac√©: ${targetPath}`)
      } catch (error) {
        console.error(`‚ùå Erreur lors du d√©placement du fichier associ√© ${fileName}:`, error.message)
      }
    } else {
      console.log(`‚ö†Ô∏è Aucun film correspondant trouv√© pour: ${fileName}`)
    }
  }

  // V√©rifier si un fichier est stable (pas en cours d'√©criture)
  async isFileStable(filePath) {
    try {
      const stats1 = await fs.promises.stat(filePath)
      await new Promise(resolve => setTimeout(resolve, 2000)) // Attendre 2 secondes
      const stats2 = await fs.promises.stat(filePath)
      
      // V√©rifier si la taille et la date de modification sont identiques
      return stats1.size === stats2.size && 
             stats1.mtime.getTime() === stats2.mtime.getTime()
    } catch (error) {
      console.error('‚ùå Erreur lors de la v√©rification de stabilit√©:', error.message)
      return false
    }
  }

  // Traiter un film
  async processMovie(filePath) {
    try {
      console.log(`üîç Traitement du film: ${path.basename(filePath)}`)
      
      // Extraire les informations du nom de fichier
      const movieInfo = this.extractMovieInfo(filePath)
      console.log('üìù Info extraite:', movieInfo)
      
      // Rechercher les m√©tadonn√©es sur TMDB
      let metadata = null
      if (this.moviedb) {
        metadata = await this.getMovieMetadata(movieInfo.title)
      }
      
      // Cr√©er le dossier de destination
      const finalTitle = metadata ? metadata.title : movieInfo.title
      const year = metadata ? metadata.year : movieInfo.year
      const folderName = year ? `${finalTitle} (${year})` : finalTitle
      const sanitizedFolderName = sanitize(folderName)
      const targetFolder = path.join(MOVIES_FOLDER, sanitizedFolderName)
      
      // Cr√©er le dossier s'il n'existe pas
      await fs.promises.mkdir(targetFolder, { recursive: true })
      
      // D√©placer le fichier vid√©o
      const fileExtension = path.extname(filePath)
      const targetFileName = `${sanitizedFolderName}${fileExtension}`
      const targetPath = path.join(targetFolder, targetFileName)
      
      await fs.promises.copyFile(filePath, targetPath)
      await fs.promises.unlink(filePath)
      
      console.log(`üì¶ Fichier d√©plac√©: ${targetPath}`)
      
      // Enregistrer les informations du film trait√©
      this.processedMovies.set(filePath, {
        cleanTitle: movieInfo.title,
        targetFolder: targetFolder,
        metadata: metadata
      })
      
      // Cr√©er le fichier d'informations
      await this.createInfoFile(targetFolder, {
        ...movieInfo,
        metadata,
        finalTitle,
        year
      })
      
      console.log(`‚úÖ Film organis√© avec succ√®s: ${folderName}`)
      
    } catch (error) {
      console.error('‚ùå Erreur lors du traitement du film:', error.message)
    }
  }

  // Extraire les informations du nom de fichier
  extractMovieInfo(filename) {
    const name = path.parse(filename).name
    const yearMatch = name.match(/(\d{4})/)
    const year = yearMatch ? parseInt(yearMatch[1]) : null
    
    let title = name
      .replace(/\d{4}.*/, '')
      .replace(/[\.\-_]+/g, ' ')
      .trim()

    return { title, year, originalName: filename }
  }

  // Rechercher sur TMDB
  async getMovieMetadata(title) {
    if (!this.moviedb) {
      console.log('‚ö†Ô∏è Cl√© API TMDB non configur√©e')
      return null
    }
    
    try {
      console.log(`üîç Recherche TMDB: "${title}"`)
      const searchResult = await this.moviedb.searchMovie({ query: title })
      
      if (searchResult.results && searchResult.results.length > 0) {
        const movie = searchResult.results[0]
        console.log(`‚úÖ Film trouv√© sur TMDB: ${movie.title} (${movie.release_date?.split('-')[0]})`)
        
        return {
          title: movie.title,
          year: movie.release_date ? new Date(movie.release_date).getFullYear() : null,
          overview: movie.overview,
          poster_path: movie.poster_path,
          backdrop_path: movie.backdrop_path,
          genres: movie.genre_ids || [],
          rating: movie.vote_average
        }
      }
      
      console.log(`‚ö†Ô∏è Aucun r√©sultat TMDB pour: ${title}`)
      return null
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration des m√©tadonn√©es TMDB:', error.message)
      return null
    }
  }

  // Cr√©er un fichier d'informations
  async createInfoFile(movieDir, movieInfo, metadata) {
    try {
      const infoData = {
        originalName: movieInfo.originalName,
        extractedTitle: movieInfo.title,
        extractedYear: movieInfo.year,
        processedDate: new Date().toISOString(),
        ...(metadata && {
          tmdb: {
            id: metadata.id,
            title: metadata.title,
            originalTitle: metadata.original_title,
            overview: metadata.overview,
            releaseDate: metadata.release_date,
            voteAverage: metadata.vote_average,
            genres: metadata.genre_ids
          }
        })
      }

      const infoPath = path.join(movieDir, 'movie.nfo')
      await fs.writeJson(infoPath, infoData, { spaces: 2 })
      console.log('üìã Fichier d\'informations cr√©√©')

    } catch (error) {
      console.error('‚ùå Erreur cr√©ation fichier info:', error)
    }
  }
}

// D√©marrer le service
const organizer = new MediaOrganizer()

// Gestion des signaux pour arr√™t propre
process.on('SIGINT', () => {
  console.log('\nüõë Arr√™t du service d\'organisation...')
  process.exit(0)
})

process.on('SIGTERM', () => {
  console.log('\nüõë Arr√™t du service d\'organisation...')
  process.exit(0)
}) 